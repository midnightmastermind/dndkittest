{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport React, { useContext, useState } from 'react';\nimport invariant from 'tiny-invariant';\nimport { OpenLayerObserverContext } from './open-layer-observer-context';\n/**\n * Layers that are registered without a namespace are grouped under this fallback namespace.\n */\nvar noNamespaceSymbol = Symbol('no-namespace');\n\n/**\n * A registered layer with its close listener and optional layer type.\n */\n\n/**\n * Returns the number of open layers across all namespaces.\n * It calculates the sum of the set sizes in the map, which corresponds to the number of open layers.\n */\nfunction getTotalOpenLayerCount(registry) {\n  return Array.from(registry.values()).reduce(function (acc, listeners) {\n    return acc + listeners.size;\n  }, 0);\n}\n\n/**\n * Returns the number of layers in the set that match the type filter.\n */\nfunction getLayerCountWithFilter(_ref) {\n  var layers = _ref.layers,\n    type = _ref.type;\n  return Array.from(layers.values()).filter(function (layer) {\n    return layer.type === type;\n  }).length;\n}\n\n/**\n * Returns the layer count change listeners set for the namespace.\n * If there are no listeners registered for the namespace yet, it creates a new set\n * and adds it to the registry, then returns the new set.\n */\nfunction getListeners(_ref2) {\n  var registry = _ref2.registry,\n    namespace = _ref2.namespace;\n  // 1. If there are existing listeners for this namespace, return the existing set.\n  var existingListeners = registry.get(namespace);\n  if (existingListeners) {\n    return existingListeners;\n  }\n\n  // 2. If there are no existing listeners for this namespace, create a new set for this namespace\n  // and add it to the registry, then return the new set.\n  var newSet = new Set();\n  registry.set(namespace, newSet);\n  return newSet;\n}\n\n/**\n * Returns an instance of the open layer observer API. It internally keeps track of the number of open layers and\n * exposes methods to get the current count, increment/decrement the count, and subscribe to changes.\n */\nfunction createInternalAPI() {\n  /**\n   * The layer count change listeners for each namespace.\n   */\n  var namespaceToChangeListenerRegistry = new Map();\n\n  /**\n   * The registered layers for each namespace.\n   * Each layer registers with an `onClose` callback, and optionally with a layer type (`type`).\n   * **When the layer is open**, its `onClose`\n   * callback is registered in this set along with its type.\n   *\n   * This data structure is also used determine the number of open layers.\n   */\n  var namespaceToLayerRegistry = new Map();\n\n  /**\n   * Calls the appropriate layer count change listeners after the number of open layers has changed.\n   */\n  function callChangeListeners(_ref3) {\n    var namespace = _ref3.namespace,\n      newCount = _ref3.newCount;\n    // 1. Call listeners registered to the specific namespace\n    if (namespace) {\n      var listenersForNamespace = namespaceToChangeListenerRegistry.get(namespace);\n\n      // Using `Array.from` to ensure we iterate over a stable list - e.g. in case a listener adds to the registry while we are\n      // iterating over it.\n      Array.from(listenersForNamespace !== null && listenersForNamespace !== void 0 ? listenersForNamespace : []).forEach(function (listener) {\n        return listener({\n          count: newCount\n        });\n      });\n    }\n\n    // 2. Call listeners registered without a specific namespace\n    var noNamespaceListeners = namespaceToChangeListenerRegistry.get(noNamespaceSymbol);\n\n    // Return early if no listeners\n    if (!noNamespaceListeners) {\n      return;\n    }\n\n    // For the listeners without a specific namespace, we need to provide the sum of all namespace counts\n    // as the callback `count` arg.\n    var totalCount = getTotalOpenLayerCount(namespaceToLayerRegistry);\n    Array.from(noNamespaceListeners).forEach(function (listener) {\n      return listener({\n        count: totalCount\n      });\n    });\n  }\n\n  /**\n   * Returns the current count of open layers.\n   *\n   * - If a namespace is provided, the count for that namespace is returned.\n   * - If a type is provided, only layers of that type are counted.\n   * - If both are provided, only layers matching both criteria are counted.\n   * - Otherwise, the sum of all namespace counts is returned.\n   */\n  function getCount() {\n    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      namespace = _ref4.namespace,\n      type = _ref4.type;\n    if (namespace) {\n      // 1. A namespace was requested, so we count only layers in that namespace\n      var layersForNamespace = namespaceToLayerRegistry.get(namespace);\n      if (!layersForNamespace) {\n        return 0;\n      }\n      if (type) {\n        // Count layers in the namespace that match the type filter\n        return getLayerCountWithFilter({\n          layers: layersForNamespace,\n          type: type\n        });\n      }\n\n      // No type filter - just return the size of the set\n      return layersForNamespace.size;\n    }\n\n    // 2. A specific namespace was not requested, so we count across all namespaces\n\n    if (type) {\n      // Count layers in each namespace that match the type filter\n      return Array.from(namespaceToLayerRegistry.values()).reduce(function (acc, layers) {\n        return acc + getLayerCountWithFilter({\n          layers: layers,\n          type: type\n        });\n      }, 0);\n    }\n\n    // No type filter - count all layers across all namespaces\n    return getTotalOpenLayerCount(namespaceToLayerRegistry);\n  }\n\n  /**\n   * Adds a listener that will be called when the number of open layers changes.\n   *\n   * @returns a cleanup function to unsubscribe, which should be called when the component unmounts.\n   */\n  function onChange(listener) {\n    var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      providedNamespace = _ref5.namespace;\n    /**\n     * We are wrapping the passed listener in a function to ensure that each call to `onChange` creates a unique\n     * function reference. This is to handle scenarios where the same function is provided to several different `onChange`\n     * calls - we want to ensure that each call to `unsubscribe` only removes the specific listener registration that was added.\n     */\n    function wrapped() {\n      listener.apply(void 0, arguments);\n    }\n    var namespace = providedNamespace !== null && providedNamespace !== void 0 ? providedNamespace : noNamespaceSymbol;\n    var listenersForNamespace = getListeners({\n      namespace: namespace,\n      registry: namespaceToChangeListenerRegistry\n    });\n    listenersForNamespace.add(wrapped);\n    return function unsubscribe() {\n      listenersForNamespace.delete(wrapped);\n\n      // If there are no listeners for this namespace, remove the registry entry.\n      if (listenersForNamespace.size === 0) {\n        namespaceToChangeListenerRegistry.delete(namespace);\n      }\n    };\n  }\n\n  /**\n   * Adds a listener to the registry that tells the observer how to close the layer component.\n   * The listener should only be added if the layer is open. This is handled by `useNotifyOpenLayerObserver`.\n   *\n   * All close listeners will be called by the observer when `closeLayers` is called.\n   *\n   * @returns a cleanup function to unsubscribe, which should be called when the component unmounts.\n   */\n  function onClose(listener, _ref6) {\n    var providedNamespace = _ref6.namespace,\n      type = _ref6.type;\n    var wrapped = {\n      listener: listener,\n      type: type\n    };\n    var namespace = providedNamespace !== null && providedNamespace !== void 0 ? providedNamespace : noNamespaceSymbol;\n    var listenersForNamespace = getListeners({\n      namespace: namespace,\n      registry: namespaceToLayerRegistry\n    });\n    listenersForNamespace.add(wrapped);\n    callChangeListeners({\n      namespace: providedNamespace,\n      newCount: listenersForNamespace.size\n    });\n    return function unsubscribe() {\n      listenersForNamespace.delete(wrapped);\n      callChangeListeners({\n        namespace: providedNamespace,\n        newCount: listenersForNamespace.size\n      });\n\n      // If there are no listeners for this namespace, remove the registry entry.\n      if (listenersForNamespace.size === 0) {\n        namespaceToLayerRegistry.delete(namespace);\n      }\n    };\n  }\n\n  /**\n   * Closes all open layers registered across all namespaces.\n   */\n  function closeLayers() {\n    // Using `Array.from` to ensure we iterate over a stable list - e.g. in case a listener adds to the registry while we are\n    // iterating over it.\n    Array.from(namespaceToLayerRegistry.values()).forEach(function (listeners) {\n      Array.from(listeners).forEach(function (_ref7) {\n        var listener = _ref7.listener;\n        return listener();\n      });\n    });\n  }\n  var internalAPI = {\n    getCount: getCount,\n    onChange: onChange,\n    onClose: onClose,\n    closeLayers: closeLayers\n  };\n  return internalAPI;\n}\n\n/**\n * Context provider for observing the number of __open__ layering components (e.g. popups, dropdown menus) under the observer.\n * It uses a stable object to keep track of the number of open layered components - which means the observer will not re-render\n * when the number of layers changes.\n *\n * There should only be one `OpenLayerObserver` in the application. If there are more, the component will throw an error.\n * To track the number of layers in a section of the application, use the `OpenLayerObserverNamespaceProvider` to create a new\n * namespace to group layers.\n *\n * It is intended for use with the `useOpenLayerObserver` hook.\n */\nexport function OpenLayerObserver(_ref8) {\n  var children = _ref8.children;\n  // Using state to ensure a stable reference to a single instance.\n  var _useState = useState(function () {\n      return createInternalAPI();\n    }),\n    _useState2 = _slicedToArray(_useState, 1),\n    internalAPI = _useState2[0];\n  var parentContext = useContext(OpenLayerObserverContext);\n\n  // We don't expect a parent context. If there is one, that means this component is nested within another `OpenLayerObserver`\n  // - which we don't support.\n  invariant(parentContext === null, '`OpenLayerObserver` cannot be nested within another `OpenLayerObserver`.');\n  return /*#__PURE__*/React.createElement(OpenLayerObserverContext.Provider, {\n    value: internalAPI\n  }, children);\n}","map":{"version":3,"names":["_slicedToArray","React","useContext","useState","invariant","OpenLayerObserverContext","noNamespaceSymbol","Symbol","getTotalOpenLayerCount","registry","Array","from","values","reduce","acc","listeners","size","getLayerCountWithFilter","_ref","layers","type","filter","layer","length","getListeners","_ref2","namespace","existingListeners","get","newSet","Set","set","createInternalAPI","namespaceToChangeListenerRegistry","Map","namespaceToLayerRegistry","callChangeListeners","_ref3","newCount","listenersForNamespace","forEach","listener","count","noNamespaceListeners","totalCount","getCount","_ref4","arguments","undefined","layersForNamespace","onChange","_ref5","providedNamespace","wrapped","apply","add","unsubscribe","delete","onClose","_ref6","closeLayers","_ref7","internalAPI","OpenLayerObserver","_ref8","children","_useState","_useState2","parentContext","createElement","Provider","value"],"sources":["/data/data/com.termux/files/home/dndkittest/node_modules/@atlaskit/layering/dist/esm/components/open-layer-observer/open-layer-observer.js"],"sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport React, { useContext, useState } from 'react';\nimport invariant from 'tiny-invariant';\nimport { OpenLayerObserverContext } from './open-layer-observer-context';\n/**\n * Layers that are registered without a namespace are grouped under this fallback namespace.\n */\nvar noNamespaceSymbol = Symbol('no-namespace');\n\n/**\n * A registered layer with its close listener and optional layer type.\n */\n\n/**\n * Returns the number of open layers across all namespaces.\n * It calculates the sum of the set sizes in the map, which corresponds to the number of open layers.\n */\nfunction getTotalOpenLayerCount(registry) {\n  return Array.from(registry.values()).reduce(function (acc, listeners) {\n    return acc + listeners.size;\n  }, 0);\n}\n\n/**\n * Returns the number of layers in the set that match the type filter.\n */\nfunction getLayerCountWithFilter(_ref) {\n  var layers = _ref.layers,\n    type = _ref.type;\n  return Array.from(layers.values()).filter(function (layer) {\n    return layer.type === type;\n  }).length;\n}\n\n/**\n * Returns the layer count change listeners set for the namespace.\n * If there are no listeners registered for the namespace yet, it creates a new set\n * and adds it to the registry, then returns the new set.\n */\nfunction getListeners(_ref2) {\n  var registry = _ref2.registry,\n    namespace = _ref2.namespace;\n  // 1. If there are existing listeners for this namespace, return the existing set.\n  var existingListeners = registry.get(namespace);\n  if (existingListeners) {\n    return existingListeners;\n  }\n\n  // 2. If there are no existing listeners for this namespace, create a new set for this namespace\n  // and add it to the registry, then return the new set.\n  var newSet = new Set();\n  registry.set(namespace, newSet);\n  return newSet;\n}\n\n/**\n * Returns an instance of the open layer observer API. It internally keeps track of the number of open layers and\n * exposes methods to get the current count, increment/decrement the count, and subscribe to changes.\n */\nfunction createInternalAPI() {\n  /**\n   * The layer count change listeners for each namespace.\n   */\n  var namespaceToChangeListenerRegistry = new Map();\n\n  /**\n   * The registered layers for each namespace.\n   * Each layer registers with an `onClose` callback, and optionally with a layer type (`type`).\n   * **When the layer is open**, its `onClose`\n   * callback is registered in this set along with its type.\n   *\n   * This data structure is also used determine the number of open layers.\n   */\n  var namespaceToLayerRegistry = new Map();\n\n  /**\n   * Calls the appropriate layer count change listeners after the number of open layers has changed.\n   */\n  function callChangeListeners(_ref3) {\n    var namespace = _ref3.namespace,\n      newCount = _ref3.newCount;\n    // 1. Call listeners registered to the specific namespace\n    if (namespace) {\n      var listenersForNamespace = namespaceToChangeListenerRegistry.get(namespace);\n\n      // Using `Array.from` to ensure we iterate over a stable list - e.g. in case a listener adds to the registry while we are\n      // iterating over it.\n      Array.from(listenersForNamespace !== null && listenersForNamespace !== void 0 ? listenersForNamespace : []).forEach(function (listener) {\n        return listener({\n          count: newCount\n        });\n      });\n    }\n\n    // 2. Call listeners registered without a specific namespace\n    var noNamespaceListeners = namespaceToChangeListenerRegistry.get(noNamespaceSymbol);\n\n    // Return early if no listeners\n    if (!noNamespaceListeners) {\n      return;\n    }\n\n    // For the listeners without a specific namespace, we need to provide the sum of all namespace counts\n    // as the callback `count` arg.\n    var totalCount = getTotalOpenLayerCount(namespaceToLayerRegistry);\n    Array.from(noNamespaceListeners).forEach(function (listener) {\n      return listener({\n        count: totalCount\n      });\n    });\n  }\n\n  /**\n   * Returns the current count of open layers.\n   *\n   * - If a namespace is provided, the count for that namespace is returned.\n   * - If a type is provided, only layers of that type are counted.\n   * - If both are provided, only layers matching both criteria are counted.\n   * - Otherwise, the sum of all namespace counts is returned.\n   */\n  function getCount() {\n    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      namespace = _ref4.namespace,\n      type = _ref4.type;\n    if (namespace) {\n      // 1. A namespace was requested, so we count only layers in that namespace\n      var layersForNamespace = namespaceToLayerRegistry.get(namespace);\n      if (!layersForNamespace) {\n        return 0;\n      }\n      if (type) {\n        // Count layers in the namespace that match the type filter\n        return getLayerCountWithFilter({\n          layers: layersForNamespace,\n          type: type\n        });\n      }\n\n      // No type filter - just return the size of the set\n      return layersForNamespace.size;\n    }\n\n    // 2. A specific namespace was not requested, so we count across all namespaces\n\n    if (type) {\n      // Count layers in each namespace that match the type filter\n      return Array.from(namespaceToLayerRegistry.values()).reduce(function (acc, layers) {\n        return acc + getLayerCountWithFilter({\n          layers: layers,\n          type: type\n        });\n      }, 0);\n    }\n\n    // No type filter - count all layers across all namespaces\n    return getTotalOpenLayerCount(namespaceToLayerRegistry);\n  }\n\n  /**\n   * Adds a listener that will be called when the number of open layers changes.\n   *\n   * @returns a cleanup function to unsubscribe, which should be called when the component unmounts.\n   */\n  function onChange(listener) {\n    var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      providedNamespace = _ref5.namespace;\n    /**\n     * We are wrapping the passed listener in a function to ensure that each call to `onChange` creates a unique\n     * function reference. This is to handle scenarios where the same function is provided to several different `onChange`\n     * calls - we want to ensure that each call to `unsubscribe` only removes the specific listener registration that was added.\n     */\n    function wrapped() {\n      listener.apply(void 0, arguments);\n    }\n    var namespace = providedNamespace !== null && providedNamespace !== void 0 ? providedNamespace : noNamespaceSymbol;\n    var listenersForNamespace = getListeners({\n      namespace: namespace,\n      registry: namespaceToChangeListenerRegistry\n    });\n    listenersForNamespace.add(wrapped);\n    return function unsubscribe() {\n      listenersForNamespace.delete(wrapped);\n\n      // If there are no listeners for this namespace, remove the registry entry.\n      if (listenersForNamespace.size === 0) {\n        namespaceToChangeListenerRegistry.delete(namespace);\n      }\n    };\n  }\n\n  /**\n   * Adds a listener to the registry that tells the observer how to close the layer component.\n   * The listener should only be added if the layer is open. This is handled by `useNotifyOpenLayerObserver`.\n   *\n   * All close listeners will be called by the observer when `closeLayers` is called.\n   *\n   * @returns a cleanup function to unsubscribe, which should be called when the component unmounts.\n   */\n  function onClose(listener, _ref6) {\n    var providedNamespace = _ref6.namespace,\n      type = _ref6.type;\n    var wrapped = {\n      listener: listener,\n      type: type\n    };\n    var namespace = providedNamespace !== null && providedNamespace !== void 0 ? providedNamespace : noNamespaceSymbol;\n    var listenersForNamespace = getListeners({\n      namespace: namespace,\n      registry: namespaceToLayerRegistry\n    });\n    listenersForNamespace.add(wrapped);\n    callChangeListeners({\n      namespace: providedNamespace,\n      newCount: listenersForNamespace.size\n    });\n    return function unsubscribe() {\n      listenersForNamespace.delete(wrapped);\n      callChangeListeners({\n        namespace: providedNamespace,\n        newCount: listenersForNamespace.size\n      });\n\n      // If there are no listeners for this namespace, remove the registry entry.\n      if (listenersForNamespace.size === 0) {\n        namespaceToLayerRegistry.delete(namespace);\n      }\n    };\n  }\n\n  /**\n   * Closes all open layers registered across all namespaces.\n   */\n  function closeLayers() {\n    // Using `Array.from` to ensure we iterate over a stable list - e.g. in case a listener adds to the registry while we are\n    // iterating over it.\n    Array.from(namespaceToLayerRegistry.values()).forEach(function (listeners) {\n      Array.from(listeners).forEach(function (_ref7) {\n        var listener = _ref7.listener;\n        return listener();\n      });\n    });\n  }\n  var internalAPI = {\n    getCount: getCount,\n    onChange: onChange,\n    onClose: onClose,\n    closeLayers: closeLayers\n  };\n  return internalAPI;\n}\n\n/**\n * Context provider for observing the number of __open__ layering components (e.g. popups, dropdown menus) under the observer.\n * It uses a stable object to keep track of the number of open layered components - which means the observer will not re-render\n * when the number of layers changes.\n *\n * There should only be one `OpenLayerObserver` in the application. If there are more, the component will throw an error.\n * To track the number of layers in a section of the application, use the `OpenLayerObserverNamespaceProvider` to create a new\n * namespace to group layers.\n *\n * It is intended for use with the `useOpenLayerObserver` hook.\n */\nexport function OpenLayerObserver(_ref8) {\n  var children = _ref8.children;\n  // Using state to ensure a stable reference to a single instance.\n  var _useState = useState(function () {\n      return createInternalAPI();\n    }),\n    _useState2 = _slicedToArray(_useState, 1),\n    internalAPI = _useState2[0];\n  var parentContext = useContext(OpenLayerObserverContext);\n\n  // We don't expect a parent context. If there is one, that means this component is nested within another `OpenLayerObserver`\n  // - which we don't support.\n  invariant(parentContext === null, '`OpenLayerObserver` cannot be nested within another `OpenLayerObserver`.');\n  return /*#__PURE__*/React.createElement(OpenLayerObserverContext.Provider, {\n    value: internalAPI\n  }, children);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}