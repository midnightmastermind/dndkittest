{"ast":null,"code":"import { useContext, useEffect } from 'react';\nimport { OpenLayerObserverContext } from './open-layer-observer-context';\nimport { useOpenLayerObserverNamespace } from './use-open-layer-observer-namespace';\n/**\n * Hook that increments/decrements the open layer count when the component mounts/unmounts or becomes visible/hidden.\n * It is used to \"notify\" the layer observer(s) that a new layer has been added/opened.\n *\n * It takes an object with two arguments:\n * - `isOpen` - used to conditionally update the layer count based on the visibility of the layered component.\n * - `onClose` - callback used to close this layer when the OpenLayerObserver has called `closeLayers`.\n *\n * Example usage:\n * ```tsx\n * const [isOpen, setIsOpen] = useState(false); // State for controlling layer visibility\n * useNotifyLayerObserver({\n *   isOpen,\n *   onClose: () => setIsOpen(false) // Optional callback to close this layer\n * });\n * ```\n */\nexport function useNotifyOpenLayerObserver(_ref) {\n  var isOpen = _ref.isOpen,\n    type = _ref.type,\n    onClose = _ref.onClose;\n  var context = useContext(OpenLayerObserverContext);\n  var namespace = useOpenLayerObserverNamespace();\n  useEffect(function () {\n    /**\n     * Registers the `onClose` callback with the OpenLayerObserver.\n     */\n\n    if (context === null) {\n      return;\n    }\n    if (!isOpen) {\n      /**\n       * If the layer is not open, we are not registering the `onClose` callback.\n       * This is important to prevent the `onClose` from being called for layers that\n       * are not open.\n       *\n       * Some consumers mistakenly pass \"toggle\" functions to `onClose` callbacks for\n       * layer components, as Popup, e.g. `onClose={() => setIsOpen(!isOpen)}`.\n       */\n      return;\n    }\n    return context.onClose(onClose, {\n      namespace: namespace,\n      type: type\n    });\n  }, [context, isOpen, namespace, onClose, type]);\n}","map":{"version":3,"names":["useContext","useEffect","OpenLayerObserverContext","useOpenLayerObserverNamespace","useNotifyOpenLayerObserver","_ref","isOpen","type","onClose","context","namespace"],"sources":["/data/data/com.termux/files/home/dndkittest/node_modules/@atlaskit/layering/dist/esm/components/open-layer-observer/use-notify-open-layer-observer.js"],"sourcesContent":["import { useContext, useEffect } from 'react';\nimport { OpenLayerObserverContext } from './open-layer-observer-context';\nimport { useOpenLayerObserverNamespace } from './use-open-layer-observer-namespace';\n/**\n * Hook that increments/decrements the open layer count when the component mounts/unmounts or becomes visible/hidden.\n * It is used to \"notify\" the layer observer(s) that a new layer has been added/opened.\n *\n * It takes an object with two arguments:\n * - `isOpen` - used to conditionally update the layer count based on the visibility of the layered component.\n * - `onClose` - callback used to close this layer when the OpenLayerObserver has called `closeLayers`.\n *\n * Example usage:\n * ```tsx\n * const [isOpen, setIsOpen] = useState(false); // State for controlling layer visibility\n * useNotifyLayerObserver({\n *   isOpen,\n *   onClose: () => setIsOpen(false) // Optional callback to close this layer\n * });\n * ```\n */\nexport function useNotifyOpenLayerObserver(_ref) {\n  var isOpen = _ref.isOpen,\n    type = _ref.type,\n    onClose = _ref.onClose;\n  var context = useContext(OpenLayerObserverContext);\n  var namespace = useOpenLayerObserverNamespace();\n  useEffect(function () {\n    /**\n     * Registers the `onClose` callback with the OpenLayerObserver.\n     */\n\n    if (context === null) {\n      return;\n    }\n    if (!isOpen) {\n      /**\n       * If the layer is not open, we are not registering the `onClose` callback.\n       * This is important to prevent the `onClose` from being called for layers that\n       * are not open.\n       *\n       * Some consumers mistakenly pass \"toggle\" functions to `onClose` callbacks for\n       * layer components, as Popup, e.g. `onClose={() => setIsOpen(!isOpen)}`.\n       */\n      return;\n    }\n    return context.onClose(onClose, {\n      namespace: namespace,\n      type: type\n    });\n  }, [context, isOpen, namespace, onClose, type]);\n}"],"mappings":"AAAA,SAASA,UAAU,EAAEC,SAAS,QAAQ,OAAO;AAC7C,SAASC,wBAAwB,QAAQ,+BAA+B;AACxE,SAASC,6BAA6B,QAAQ,qCAAqC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,0BAA0BA,CAACC,IAAI,EAAE;EAC/C,IAAIC,MAAM,GAAGD,IAAI,CAACC,MAAM;IACtBC,IAAI,GAAGF,IAAI,CAACE,IAAI;IAChBC,OAAO,GAAGH,IAAI,CAACG,OAAO;EACxB,IAAIC,OAAO,GAAGT,UAAU,CAACE,wBAAwB,CAAC;EAClD,IAAIQ,SAAS,GAAGP,6BAA6B,CAAC,CAAC;EAC/CF,SAAS,CAAC,YAAY;IACpB;AACJ;AACA;;IAEI,IAAIQ,OAAO,KAAK,IAAI,EAAE;MACpB;IACF;IACA,IAAI,CAACH,MAAM,EAAE;MACX;AACN;AACA;AACA;AACA;AACA;AACA;AACA;MACM;IACF;IACA,OAAOG,OAAO,CAACD,OAAO,CAACA,OAAO,EAAE;MAC9BE,SAAS,EAAEA,SAAS;MACpBH,IAAI,EAAEA;IACR,CAAC,CAAC;EACJ,CAAC,EAAE,CAACE,OAAO,EAAEH,MAAM,EAAEI,SAAS,EAAEF,OAAO,EAAED,IAAI,CAAC,CAAC;AACjD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}